---
title: "Fixing the Data / Multiple Expert Issue"
author: "Rob Schick, PhD"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fixing the Data / Multiple Expert Issue}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo=FALSE}
rm(list = ls())
library(eliciteg)
data(moveData)
```

In the `multipleExpertProblem` vignette, I raised the issue of how I was struggling to get good `c` values returned from the `calcC` function, which in return was causing `calcK` to return `NA` values. I showed these to Michail, and he corrected my indexing of the data/prior combo that was going into these functions. Specifically, I was sending the whole `9 x 9` matrix, when I really wanted to be sending a `1 x 9` vector for both of the data and the prior. 

I tried first tackling this with `mapply()`, but didn't get very far - as it wasn't returning what I wanted. (Most likely due to my admittedly poor comprehension of the `apply` family of functions.) What I want is a matrix that holds all `c` values. The dimensions would be `nrow` = # experts, and `ncol = nreg`. So for one element of that matrix, I'd see something like this:

```{r, eval=FALSE}
outMat[1, 1] <- calcC(dat[, 1], priorList$males$exp1[, 1])
outMat[2, 1] <- calcC(dat[, 1], priorList$males$exp2[, 1])
outMat[3, 1] <- calcC(dat[, 1], priorList$males$exp3[, 1])
```

And so on. What that would mean is that the first column of the matrix (`outMat[, 1]`) would contain all the `c` values for each expert/data combination for the first region. The second column of the matrix (`outMat[, 2]`) would contain all the `c` values for each expert/data combination for the second region, etc.

Here's my first attempt and calculating that for one whole expert/region combination. I've pared down the data & prior dimension to make it a bit easier to see and puzzle through. First the (pared) data, and prior (from expert 4):

```{r}
maleExT <- maleEx[5:9, 5:9]
priorT <- priorList$males$exp4[5:9, 5:9]
maleExT
priorT
```

And then we set up the matrix to hold the data, conduct the calculation, and print the output:

```{r}
cmatOut <- matrix(NA, nrow = 1, ncol = dim(maleExT)[2])

for(i in seq_along(1:dim(maleExT)[2])){
 cmatOut[, i] <- calcC(maleExT[, i], priorT[, i])
}
cmatOut
```

That is one row matrix that has the `c` weight for this one individual expert over all five regions. However I need to do this for all experts and regions (actually I'm still only using 5 regions here). While my solution that uses a loop is a kludgy way to do this, I want to get it right first.

Here's the initialisation of the output array:

```{r}
cmatOut <- matrix(NA, nrow = length(priorList$males), 
                  ncol = dim(maleExT)[2],
                  dimnames = list(c('exp1', 'exp2', 'exp3', 'exp4', 
                                           'exp5', 'exp6', 'exp7', 'exp8'),
                                  colnames(maleExT)))
```

Note that the rows correspond to the number of experts, while the columns correspond to the number of regions. With that set up, we can populate it with a nested set of loops:

```{r}
for(i in seq_along(1:dim(maleExT)[2])){
  for(j in seq_along(1:length(priorList$males))){
    priorT <- priorList$males[[j]][5:9, 5:9]
    cmatOut[j, i] <- calcC(maleExT[, i], priorT[, i])
  }
}
cmatOut
```

## `calcK`
Next up is to send the results from `cmatOut` on to `calcK` for processing. I'll still do this for the subset of regions just to make sure things are working. Once done, I can expand outward. The way I did this previously was to loop over a list with `lapply`, which I'll replace with `apply` since I no longer have an input list. And while I can still use the function the output will no longer be a list, so I'll change the name of the output object. The processing logic, then, is to take a column's worth of c-vales, and from them, calculate the `K` values:

```{r}
kmat <- apply(cmatOut, 2, function(x) calcK(x))
kmat
colSums(kmat)
```

That output, then, is a matrix where each column is the probability vector (that sums to 1), which we will use to select the expert within the Gibbs loop.

## Sample Individual Experts
Let's start with males. To do this, I have to first pair down the list to match the number of regions in the example above.

```{r parePriorList}
priorListMalesT <- lapply(priorList$males, function(x) x[5:9, 5:9])
```


With the dimensions now reduced, we can move on to the sampling. Here I'll simulate a Gibbs loop for males.
```{r maleGibbs}
ng <- 100
nregions <- ncol(kmat)
post <- matrix(0, nregions, nregions)  
summh <- post 
for(i in seq_along(1:ng)){

    for(j in seq_along(1:nregions)){
  
      idx <- which(rmultinom(1, 1, kmat[, j]) == 1) # chooses the expert
      prior <- priorListMalesT[[idx]][, j] # gets prior for that expert
    
      di <- matrix(rgamma(nregions * 1, 
                    shape = maleExT[, j] + prior, 
                    scale = 1), nregions, 1) 

      post[, j] <- di / matrix(colSums(di), nregions, 1, byrow = T) 

    } 
  summh <- summh + post
}

malemovePostprob <- summh / ng
round(malemovePostprob, 3)
```

That looks good as a quick first cut at it. Next up is to do it for all 9 regions.


